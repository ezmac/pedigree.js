<!DOCTYPE html>
<html>
<body>

<canvas id="myCanvas" width="1000" height="1000" style="border:1px solid #d3d3d3;">
Your browser does not support the HTML5 canvas tag.</canvas>

<script>
//https://eloquentjavascript.net/1st_edition/chapter4.html
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");

var numGenerations = 4; //How many generations the pedigree chart should span (must be greater than zero)
var numParents = 2; //Generally leave this at 2 unless you have a weird race that requires more or fewer than two parents to give birth a new individual (must be integer >= 1)
var box = {height:50, width:100, border:"black", fill:"white", posX:0, posY:0};
var connector = 50; //The width of the space between boxes of different generations
var pedigree = generatePedigree();
var vertSpacer = 25; //minimum vertical space between boxes of the same generation    

//set canvas dimensions based on the number of generations and box size
c.width = (numGenerations * box.width) + (connector * (numGenerations - 1));
c.height = (Math.pow(numParents, (numGenerations - 1)) * box.height) + ((Math.pow(numParents, (numGenerations - 1)) - 1) * vertSpacer);
console.log("Canvas height is: " + c.height + "px");

//  calcBoundaryPoint is supposed to determine where to place the first/topmost 
//  element of a column in the pedigree
function calcBoundaryPoint (numItems, canvasHeight) {
    var startPoint = (1 / (numItems * 2)) * canvasHeight;
    return startPoint;
}
    
function calcSpacing (bottom, top, numItems) {
    if (numItems <= 1) {
        //this if statement is to avoid a divide by zero issue
        var spacing = 0;
    } else {
        var spacing = (bottom - top) / (numItems - 1);   
    }
    return spacing;
}
    
function calcVertOffset (numItems, canvasHeight) {
    var offset = canvasHeight / (numItems + 1);
    return offset;
}

function createPerson (test) {
    var person = new Object();
    switch (test % 2) {
        case 0:
            person.name = "Cheese";
            person.age = 18;
            break;
        case 1:
            person.name = "Toast";
            person.age = 21;
            break;
        default:
            person.name = "Nope";
            person.age = 65;
            break;
    }
        
    return person;
}

function drawConnectors (parentX, parentY, childX, childY, color, width) {
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
        
    ctx.moveTo(parentX, parentY);
    ctx.lineTo(parentX - ((parentX - childX) / 2), parentY);
    ctx.lineTo(parentX - ((parentX - childX) / 2), childY);
    ctx.lineTo(childX, childY);
    
    ctx.stroke();
}
    
function drawPedigree () {
    var bottomPoint = 0; //bottom boundary for column
    var curPerson = 0;
    var curX = 0;
    var curY = 0;
    console.log(curY);
    var distCenter = 0; //distance between vertical centers
    var topPoint = 0; //top boundary for column
    
    ctx.beginPath();
    ctx.strokeStyle = box.border;
    ctx.fillStyle = box.fill;
    
    for (var i = 1; i <= numGenerations; i++) {
        if (i == numGenerations) {
            curY = 0;
            for (var j = 0; j < Math.pow(numParents, i - 1); j++) {
                ctx.rect(curX, curY, box.width, box.height);
                pedigree[curPerson].cx = curX;
                pedigree[curPerson].cy = curY + (box.height / 2);
                pedigree[curPerson].px = curX + box.width;
                pedigree[curPerson].py = curY + (box.height / 2);
                console.log("cx " + pedigree[curPerson].cx + " cy " + pedigree[curPerson].cy + " px " + pedigree[curPerson].px + " py " + pedigree[curPerson].py);
                curY += (box.height + vertSpacer);
                curPerson++;
            }
        } else {
            topPoint = Math.floor(calcBoundaryPoint(Math.pow(numParents, i - 1), c.height));
            console.log("topPoint is " + topPoint + "px");
            bottomPoint = Math.floor(c.height - topPoint);
            console.log("bottomPoint is " + bottomPoint + "px");
            curY = Math.floor(calcBoundaryPoint(Math.pow(numParents, i - 1), c.height) + ((box.height / 2) * (-1)));
            console.log("Outer curY is " + curY + "px");
            distCenter = calcSpacing (bottomPoint, topPoint, Math.pow(numParents, i - 1));
            console.log("DistCenter is " + distCenter);
            //distCenter = Math.floor((c.height - (calcBoundaryPoint(Math.pow(numParents, i - 1), c.height) * 2)) / Math.pow(numParents, i - 1));
            for (var j = 0; j < Math.pow(numParents, i - 1); j++) {
                ctx.rect(curX, curY, box.width, box.height);
                console.log("Inner curY is " + curY + "px");
                
                // test code
                pedigree[curPerson].cx = curX;
                pedigree[curPerson].cy = curY + (box.height / 2);
                pedigree[curPerson].px = curX + box.width;
                pedigree[curPerson].py = curY + (box.height / 2);
                console.log("cx " + pedigree[curPerson].cx + " cy " + pedigree[curPerson].cy + " px " + pedigree[curPerson].px + " py " + pedigree[curPerson].py);
                //end test code
                
                curY += distCenter;
                curPerson++;
            }
            curX += (box.width + connector);
        }
        
        //curY = (box.height / 2) * (-1);
        console.log(curY);
        
        
        
    }
    
    ctx.stroke();
}

function generateName () {
    
}
    
function generatePedigree () {
    var pedArr = new Array();
    
    for (var i = 1; i <= numGenerations; i++) {
        for (var j = 0; j < Math.pow(numParents, i - 1); j++) {
            pedArr.push(createPerson(i));
        }
    }
    return pedArr;
}
    
//test code

for (i = 0; i <= pedigree.length - 1; i++) {
    console.log("pedigree" + i + " is " + pedigree[i].name + " compared to 0, which is " + pedigree[0].name);
}

pedigree[0].ninja = "yes";
console.log(pedigree[0].ninja);
    
//end test

drawPedigree();

//drawConnectors(c.width - box.width, 100, c.width - box.width - connector, 75, "black", 2);
//okay so this is super kludgy but I don't care because I'm testing, so I'm going to manually specify the connection points to draw via function and i'll fix the math later
drawConnectors(pedigree[1].cx, pedigree[1].cy, pedigree[0].px, pedigree[0].py, 2);
drawConnectors(pedigree[2].cx, pedigree[2].cy, pedigree[0].px, pedigree[0].py, 2);
drawConnectors(pedigree[3].cx, pedigree[3].cy, pedigree[1].px, pedigree[1].py, 2);
drawConnectors(pedigree[4].cx, pedigree[4].cy, pedigree[1].px, pedigree[1].py, 2);
drawConnectors(pedigree[5].cx, pedigree[5].cy, pedigree[2].px, pedigree[2].py, 2);
drawConnectors(pedigree[6].cx, pedigree[6].cy, pedigree[2].px, pedigree[2].py, 2);
drawConnectors(pedigree[7].cx, pedigree[7].cy, pedigree[3].px, pedigree[3].py, 2);
drawConnectors(pedigree[8].cx, pedigree[8].cy, pedigree[3].px, pedigree[3].py, 2);
drawConnectors(pedigree[9].cx, pedigree[9].cy, pedigree[4].px, pedigree[4].py, 2);
drawConnectors(pedigree[10].cx, pedigree[10].cy, pedigree[4].px, pedigree[4].py, 2);
drawConnectors(pedigree[11].cx, pedigree[11].cy, pedigree[5].px, pedigree[5].py, 2);
drawConnectors(pedigree[12].cx, pedigree[12].cy, pedigree[5].px, pedigree[5].py, 2);
drawConnectors(pedigree[13].cx, pedigree[13].cy, pedigree[6].px, pedigree[6].py, 2);
drawConnectors(pedigree[14].cx, pedigree[14].cy, pedigree[6].px, pedigree[6].py, 2);

</script>
</body>
</html>
